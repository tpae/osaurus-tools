name: Build Plugin (Reusable)

# Reusable workflow for building, signing, and releasing Osaurus plugins.
# Zero inputs required - everything is extracted from get_manifest().
#
# External plugin repositories call this workflow to:
# 1. Build their Swift plugin as a dylib
# 2. Auto-detect the dylib and extract manifest (plugin_id, name, etc.)
# 3. Package and sign the artifact
# 4. Create a GitHub Release
# 5. Submit a PR to the osaurus-tools registry
#
# Note: Some outputs are base64 encoded to prevent GitHub Actions from
# blocking them due to secret substring matching.

on:
  workflow_call:
    inputs:
      swift_version:
        description: 'Swift version'
        required: false
        type: string
        default: '6.0'
      macos_version:
        description: 'macOS runner'
        required: false
        type: string
        default: 'macos-15'
    secrets:
      DEVELOPER_ID_CERTIFICATE_P12_BASE64:
        required: true
      DEVELOPER_ID_CERTIFICATE_PASSWORD:
        required: true
      MINISIGN_SECRET_KEY:
        required: true
      MINISIGN_PASSWORD:
        required: true
      MINISIGN_PUBLIC_KEY:
        required: true
      REGISTRY_PAT:
        required: true

permissions:
  contents: write

jobs:
  build:
    runs-on: ${{ inputs.macos_version }}
    outputs:
      version: ${{ steps.version.outputs.version }}
      plugin_id_b64: ${{ steps.extract.outputs.plugin_id_b64 }}
      manifest_b64: ${{ steps.extract.outputs.manifest_b64 }}
      artifact_url_b64: ${{ steps.urls.outputs.artifact_url_b64 }}
      sha256: ${{ steps.package.outputs.sha256 }}
      signature_b64: ${{ steps.sign.outputs.signature_b64 }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version from tag
        id: version
        run: |
          VERSION="${GITHUB_REF#refs/tags/}"
          VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Set up Swift
        uses: swift-actions/setup-swift@v2
        with:
          swift-version: ${{ inputs.swift_version }}

      - name: Build release
        run: swift build -c release

      - name: Find dylib
        id: find
        run: |
          DYLIB=$(ls .build/release/*.dylib 2>/dev/null | head -1)
          if [ -z "$DYLIB" ] || [ ! -f "$DYLIB" ]; then
            echo "::error::No dylib found in .build/release/"
            exit 1
          fi
          echo "dylib=$DYLIB" >> $GITHUB_OUTPUT

      - name: Install Osaurus CLI
        run: |
          brew update
          brew install --cask osaurus

      - name: Extract manifest from dylib
        id: extract
        run: |
          MANIFEST=$(osaurus manifest extract "${{ steps.find.outputs.dylib }}")

          echo "$MANIFEST" | jq . > /dev/null || {
            echo "::error::Invalid JSON from manifest extraction"
            exit 1
          }

          PLUGIN_ID=$(echo "$MANIFEST" | jq -r '.plugin_id')
          if [ -z "$PLUGIN_ID" ] || [ "$PLUGIN_ID" = "null" ]; then
            echo "::error::No plugin_id in manifest"
            exit 1
          fi

          echo "plugin_id=$PLUGIN_ID" >> $GITHUB_OUTPUT
          echo "plugin_id_b64=$(echo -n "$PLUGIN_ID" | base64)" >> $GITHUB_OUTPUT
          echo "manifest_b64=$(echo "$MANIFEST" | jq -c . | base64)" >> $GITHUB_OUTPUT

          echo "Extracted plugin_id: $PLUGIN_ID"

      - name: Code sign
        env:
          DEVELOPER_ID_CERTIFICATE_P12_BASE64: ${{ secrets.DEVELOPER_ID_CERTIFICATE_P12_BASE64 }}
          DEVELOPER_ID_CERTIFICATE_PASSWORD: ${{ secrets.DEVELOPER_ID_CERTIFICATE_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "$DEVELOPER_ID_CERTIFICATE_P12_BASE64" | base64 --decode > $RUNNER_TEMP/cert.p12
          security import $RUNNER_TEMP/cert.p12 -P "$DEVELOPER_ID_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID" | head -1 | sed 's/.*"\(.*\)".*/\1/')

          codesign --force --options runtime --timestamp --sign "$IDENTITY" "${{ steps.find.outputs.dylib }}"
          codesign --verify --verbose "${{ steps.find.outputs.dylib }}"

          rm -f $RUNNER_TEMP/cert.p12

      - name: Package
        id: package
        run: |
          PLUGIN_ID="${{ steps.extract.outputs.plugin_id }}"
          VERSION="${{ steps.version.outputs.version }}"
          ARTIFACT="${PLUGIN_ID}-${VERSION}-macos-arm64.zip"

          zip -j "$ARTIFACT" "${{ steps.find.outputs.dylib }}"

          echo "sha256=$(shasum -a 256 "$ARTIFACT" | cut -d ' ' -f 1)" >> $GITHUB_OUTPUT
          echo "artifact=$ARTIFACT" >> $GITHUB_OUTPUT

      - name: Sign with minisign
        id: sign
        env:
          MINISIGN_SECRET_KEY: ${{ secrets.MINISIGN_SECRET_KEY }}
          MINISIGN_PASSWORD: ${{ secrets.MINISIGN_PASSWORD }}
        run: |
          brew install minisign
          echo "$MINISIGN_SECRET_KEY" > $RUNNER_TEMP/minisign.key

          echo "$MINISIGN_PASSWORD" | minisign -Slm "${{ steps.package.outputs.artifact }}" -s $RUNNER_TEMP/minisign.key

          echo "signature_b64=$(base64 -i "${{ steps.package.outputs.artifact }}.minisig")" >> $GITHUB_OUTPUT

          rm -f $RUNNER_TEMP/minisign.key

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.package.outputs.artifact }}
            ${{ steps.package.outputs.artifact }}.minisig
          generate_release_notes: true
          fail_on_unmatched_files: false

      - name: Set artifact URL
        id: urls
        run: |
          ARTIFACT_URL="${{ github.server_url }}/${{ github.repository }}/releases/download/${{ github.ref_name }}/${{ steps.package.outputs.artifact }}"
          echo "artifact_url_b64=$(echo -n "$ARTIFACT_URL" | base64)" >> $GITHUB_OUTPUT

  registry-pr:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Generate registry manifest
        env:
          MANIFEST_B64: ${{ needs.build.outputs.manifest_b64 }}
          PLUGIN_ID_B64: ${{ needs.build.outputs.plugin_id_b64 }}
          ARTIFACT_URL_B64: ${{ needs.build.outputs.artifact_url_b64 }}
          SIGNATURE_B64: ${{ needs.build.outputs.signature_b64 }}
        run: |
          PLUGIN_ID=$(echo "$PLUGIN_ID_B64" | base64 -d)
          MANIFEST=$(echo "$MANIFEST_B64" | base64 -d)
          ARTIFACT_URL=$(echo "$ARTIFACT_URL_B64" | base64 -d)
          SIGNATURE=$(echo "$SIGNATURE_B64" | base64 -d)

          NAME=$(echo "$MANIFEST" | jq -r '.name // empty')
          DESCRIPTION=$(echo "$MANIFEST" | jq -r '.description // ""')
          LICENSE=$(echo "$MANIFEST" | jq -r '.license // "MIT"')
          AUTHORS=$(echo "$MANIFEST" | jq -c '.authors // ["${{ github.repository_owner }}"]')
          MIN_MACOS=$(echo "$MANIFEST" | jq -r '.min_macos // "13.0"')
          MIN_OSAURUS=$(echo "$MANIFEST" | jq -r '.min_osaurus // "0.5.0"')
          TOOLS=$(echo "$MANIFEST" | jq -c '.capabilities.tools // []')

          if [ -z "$NAME" ]; then
            NAME=$(echo "$PLUGIN_ID" | rev | cut -d. -f1 | rev)
            NAME="$(tr '[:lower:]' '[:upper:]' <<< ${NAME:0:1})${NAME:1}"
          fi

          jq -n \
            --arg plugin_id "$PLUGIN_ID" \
            --arg name "$NAME" \
            --arg description "$DESCRIPTION" \
            --arg homepage "${{ github.server_url }}/${{ github.repository }}" \
            --arg license "$LICENSE" \
            --argjson authors "$AUTHORS" \
            --argjson tools "$TOOLS" \
            --arg minisign_pubkey "${{ secrets.MINISIGN_PUBLIC_KEY }}" \
            --arg min_macos "$MIN_MACOS" \
            --arg min_osaurus "$MIN_OSAURUS" \
            --arg version "${{ needs.build.outputs.version }}" \
            --arg release_date "$(date -u +%Y-%m-%d)" \
            --arg url "$ARTIFACT_URL" \
            --arg sha256 "${{ needs.build.outputs.sha256 }}" \
            --arg signature "$SIGNATURE" \
            '{
              plugin_id: $plugin_id,
              name: $name,
              description: $description,
              homepage: $homepage,
              license: $license,
              authors: $authors,
              capabilities: { tools: $tools },
              public_keys: { minisign: $minisign_pubkey },
              requires: { min_macos: $min_macos, osaurus_min_version: $min_osaurus },
              versions: [{
                version: $version,
                release_date: $release_date,
                artifacts: [{
                  os: "macos",
                  arch: "arm64",
                  url: $url,
                  sha256: $sha256,
                  min_macos: $min_macos,
                  minisign: { signature: $signature }
                }]
              }]
            }' > registry-manifest.json

          cat registry-manifest.json | jq .

      - name: Upload manifest artifact
        uses: actions/upload-artifact@v4
        with:
          name: registry-manifest
          path: registry-manifest.json

      - name: Create PR via fork
        env:
          GH_TOKEN: ${{ secrets.REGISTRY_PAT }}
          PLUGIN_ID_B64: ${{ needs.build.outputs.plugin_id_b64 }}
        run: |
          PLUGIN_ID=$(echo "$PLUGIN_ID_B64" | base64 -d)
          VERSION="${{ needs.build.outputs.version }}"
          OWNER="${{ github.repository_owner }}"
          BRANCH="plugin/${PLUGIN_ID}-${VERSION}"

          gh repo fork dinoki-ai/osaurus-tools --clone=false || true
          sleep 3

          git clone "https://x-access-token:${GH_TOKEN}@github.com/${OWNER}/osaurus-tools.git" /tmp/registry
          cd /tmp/registry

          git remote add upstream https://github.com/dinoki-ai/osaurus-tools.git
          git fetch upstream
          git checkout -B master upstream/master
          git push origin master --force

          git checkout -b "$BRANCH"

          MANIFEST_PATH="plugins/${PLUGIN_ID}.json"
          mkdir -p plugins

          if [ -f "$MANIFEST_PATH" ]; then
            jq --slurpfile new "$GITHUB_WORKSPACE/registry-manifest.json" \
              '.versions = [$new[0].versions[0]] + .versions | .versions |= unique_by(.version)' \
              "$MANIFEST_PATH" > tmp.json && mv tmp.json "$MANIFEST_PATH"
          else
            cp "$GITHUB_WORKSPACE/registry-manifest.json" "$MANIFEST_PATH"
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "$MANIFEST_PATH"
          git commit -m "Add ${PLUGIN_ID} v${VERSION}"
          git push origin "$BRANCH"

          gh pr create \
            --repo dinoki-ai/osaurus-tools \
            --head "${OWNER}:${BRANCH}" \
            --title "Add ${PLUGIN_ID} v${VERSION}" \
            --body "$(cat <<EOF
**Plugin:** \`${PLUGIN_ID}\`
**Version:** \`${VERSION}\`
**Source:** [${{ github.repository }}](${{ github.server_url }}/${{ github.repository }})

---
*Auto-generated from plugin manifest*
EOF
)"
