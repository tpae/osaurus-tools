name: Build and Release Plugin

on:
  push:
    tags:
      # Match tags like: time-1.0.0, git-1.0.0
      - "*-*.*.*"
  workflow_dispatch:
    inputs:
      tool:
        description: "Tool to build (time, git, browser, fetch, search, filesystem, all)"
        required: true
        type: choice
        options:
          - time
          - git
          - browser
          - fetch
          - search
          - filesystem
          - all
      version:
        description: "Version (e.g., 1.0.0)"
        required: true
        type: string

permissions:
  contents: write

jobs:
  build:
    runs-on: macos-latest

    outputs:
      plugin_id: ${{ steps.extract.outputs.plugin_id }}
      manifest: ${{ steps.extract.outputs.manifest }}
      version: ${{ steps.parse.outputs.version }}
      artifact_name: ${{ steps.package.outputs.artifact_name }}
      sha256: ${{ steps.package.outputs.sha256 }}
      size: ${{ steps.package.outputs.size }}
      minisign_signature_b64: ${{ steps.sign.outputs.minisign_signature_b64 }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse tag or inputs
        id: parse
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TOOL="${{ github.event.inputs.tool }}"
            VERSION="${{ github.event.inputs.version }}"
          else
            # Parse from tag: tool-version (e.g., time-1.0.0)
            TAG="${GITHUB_REF#refs/tags/}"
            TOOL="${TAG%%-*}"
            VERSION="${TAG#*-}"
          fi
          echo "tool=$TOOL" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building $TOOL version $VERSION"

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Import Code Signing Certificate
        id: codesign
        env:
          CERTIFICATE_P12_BASE64: ${{ secrets.DEVELOPER_ID_CERTIFICATE_P12_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.DEVELOPER_ID_CERTIFICATE_PASSWORD }}
        run: |
          if [ -z "$CERTIFICATE_P12_BASE64" ]; then
            echo "No DEVELOPER_ID_CERTIFICATE_P12_BASE64 configured, will use ad-hoc signing"
            echo "identity=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create a temporary keychain
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          CERT_PATH="$RUNNER_TEMP/certificate.p12"
          echo "$CERTIFICATE_P12_BASE64" | base64 --decode > "$CERT_PATH"

          security import "$CERT_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Add keychain to search list
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

          # Allow codesign to access the key without prompting
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Extract signing identity from certificate
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID Application" | head -1 | sed 's/.*"\(.*\)".*/\1/')

          if [ -z "$IDENTITY" ]; then
            echo "::error::No Developer ID Application certificate found in keychain"
            exit 1
          fi

          echo "Found signing identity: $IDENTITY"
          echo "identity=$IDENTITY" >> $GITHUB_OUTPUT

          # Store keychain path for cleanup
          echo "keychain_path=$KEYCHAIN_PATH" >> $GITHUB_OUTPUT

          # Clean up temp cert file
          rm -f "$CERT_PATH"

      - name: Build plugin
        id: build
        run: |
          TOOL="${{ steps.parse.outputs.tool }}"
          TOOL_DIR="tools/$TOOL"

          cd "$TOOL_DIR"
          swift build -c release

          # Find the built dylib
          DYLIB=$(ls .build/release/*.dylib 2>/dev/null | head -1)
          if [ -z "$DYLIB" ] || [ ! -f "$DYLIB" ]; then
            echo "::error::No dylib found in .build/release/"
            ls -la .build/release/
            exit 1
          fi

          echo "dylib=$TOOL_DIR/$DYLIB" >> $GITHUB_OUTPUT
          echo "tool_dir=$TOOL_DIR" >> $GITHUB_OUTPUT
          echo "Found dylib: $DYLIB"

      - name: Install Osaurus CLI
        run: |
          brew update
          brew install --cask osaurus

      - name: Extract manifest from dylib
        id: extract
        run: |
          DYLIB="${{ steps.build.outputs.dylib }}"
          MANIFEST=$(osaurus manifest extract "$DYLIB")

          # Validate JSON
          echo "$MANIFEST" | jq . > /dev/null || {
            echo "::error::Invalid JSON from manifest extraction"
            exit 1
          }

          # Extract plugin_id for use in later steps
          PLUGIN_ID=$(echo "$MANIFEST" | jq -r '.plugin_id')
          if [ -z "$PLUGIN_ID" ] || [ "$PLUGIN_ID" = "null" ]; then
            echo "::error::No plugin_id in manifest"
            exit 1
          fi

          echo "plugin_id=$PLUGIN_ID" >> $GITHUB_OUTPUT

          # Store compacted manifest using heredoc syntax to handle large outputs
          MANIFEST_COMPACT=$(echo "$MANIFEST" | jq -c .)
          {
            echo "manifest<<EOF"
            echo "$MANIFEST_COMPACT"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "Extracted plugin_id: $PLUGIN_ID"
          echo "Full manifest:"
          echo "$MANIFEST" | jq .

      - name: Code sign dylib
        env:
          CODESIGN_IDENTITY: ${{ steps.codesign.outputs.identity }}
        run: |
          DYLIB="${{ steps.build.outputs.dylib }}"

          if [ -n "$CODESIGN_IDENTITY" ]; then
            echo "Signing dylib with Developer ID..."
            codesign --force --options runtime --timestamp --sign "$CODESIGN_IDENTITY" "$DYLIB"
            codesign --verify --verbose "$DYLIB"
            echo "Signed with Developer ID"
          else
            echo "Ad-hoc signing dylib (no CODESIGN_IDENTITY set)..."
            codesign -s - -f "$DYLIB"
            echo "Ad-hoc signed"
          fi

      - name: Package artifact
        id: package
        run: |
          TOOL="${{ steps.parse.outputs.tool }}"
          VERSION="${{ steps.parse.outputs.version }}"
          PLUGIN_ID="${{ steps.extract.outputs.plugin_id }}"
          DYLIB="${{ steps.build.outputs.dylib }}"

          # Create build output directory
          BUILD_DIR="build/$TOOL"
          mkdir -p "$BUILD_DIR"

          # Create artifact name
          ARTIFACT="${PLUGIN_ID}-${VERSION}-macos-arm64.zip"

          # Create zip with just the dylib
          zip -j "$BUILD_DIR/$ARTIFACT" "$DYLIB"

          # Compute SHA256 and size
          SHA256=$(shasum -a 256 "$BUILD_DIR/$ARTIFACT" | cut -d ' ' -f 1)
          SIZE=$(stat -f%z "$BUILD_DIR/$ARTIFACT" 2>/dev/null || stat --printf="%s" "$BUILD_DIR/$ARTIFACT")

          echo "artifact_name=$ARTIFACT" >> $GITHUB_OUTPUT
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "size=$SIZE" >> $GITHUB_OUTPUT

          echo "Created artifact: $ARTIFACT"
          echo "SHA256: $SHA256"
          echo "Size: $SIZE bytes"

      - name: Sign with Minisign
        id: sign
        env:
          MINISIGN_SECRET_KEY: ${{ secrets.MINISIGN_SECRET_KEY }}
          MINISIGN_PASSWORD: ${{ secrets.MINISIGN_PASSWORD }}
        run: |
          # Skip if no signing key
          if [ -z "$MINISIGN_SECRET_KEY" ]; then
            echo "No MINISIGN_SECRET_KEY configured, skipping signing"
            echo "minisign_signature_b64=" >> $GITHUB_OUTPUT
            exit 0
          fi

          TOOL="${{ steps.parse.outputs.tool }}"
          ARTIFACT="${{ steps.package.outputs.artifact_name }}"

          # Install minisign
          brew install minisign

          # Write secret key to temp file
          echo "$MINISIGN_SECRET_KEY" > $RUNNER_TEMP/minisign.key

          # Sign the zip using legacy format (-l) for compatibility with Osaurus
          # Modern minisign uses "ED" algorithm ID, but Osaurus expects "Ed" (legacy format)
          cd "build/$TOOL"
          echo "=== Signing $ARTIFACT (legacy format) ==="
          echo "Command: minisign -Slm $ARTIFACT -s <keyfile> -x ${ARTIFACT}.minisig"

          if [ -n "$MINISIGN_PASSWORD" ]; then
            echo "$MINISIGN_PASSWORD" | minisign -Slm "$ARTIFACT" -s $RUNNER_TEMP/minisign.key -x "${ARTIFACT}.minisig"
          else
            minisign -Slm "$ARTIFACT" -s $RUNNER_TEMP/minisign.key -x "${ARTIFACT}.minisig" -W
          fi

          # Debug: Show the signature file contents
          echo "=== Generated signature file ==="
          cat "${ARTIFACT}.minisig"
          echo ""
          echo "=== Signature file format check ==="
          head -1 "${ARTIFACT}.minisig" | grep -q "prehashed" && echo "WARNING: Signature is prehashed!" || echo "OK: Signature is NOT prehashed"

          # Note: Verification would require public key, skipping in CI
          echo "=== Signature generated successfully ==="

          # Read full signature file and base64 encode for safe transport
          SIGNATURE_B64=$(base64 -i "${ARTIFACT}.minisig")
          echo "minisign_signature_b64=$SIGNATURE_B64" >> $GITHUB_OUTPUT

          echo "=== Base64 encoded signature ==="
          echo "$SIGNATURE_B64"

          # Clean up
          rm -f $RUNNER_TEMP/minisign.key

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.package.outputs.artifact_name }}
          path: |
            build/${{ steps.parse.outputs.tool }}/${{ steps.package.outputs.artifact_name }}
            build/${{ steps.parse.outputs.tool }}/${{ steps.package.outputs.artifact_name }}.minisig
          if-no-files-found: warn

      - name: Cleanup Keychain
        if: always()
        run: |
          KEYCHAIN_PATH="${{ steps.codesign.outputs.keychain_path }}"
          if [ -n "$KEYCHAIN_PATH" ] && [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi

  release:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.artifact_name }}
          path: ./release

      - name: Parse tag
        id: tag
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TOOL="${{ github.event.inputs.tool }}"
            VERSION="${{ github.event.inputs.version }}"
            TAG="${TOOL}-${VERSION}"
          else
            TAG="${GITHUB_REF#refs/tags/}"
            TOOL="${TAG%%-*}"
            VERSION="${TAG#*-}"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "tool=$TOOL" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: "${{ needs.build.outputs.plugin_id }} v${{ needs.build.outputs.version }}"
          body: |
            ## ${{ needs.build.outputs.plugin_id }} v${{ needs.build.outputs.version }}

            ### Installation

            ```bash
            osaurus tools install ${{ needs.build.outputs.plugin_id }}
            ```

            ### Artifact Details

            - **File:** `${{ needs.build.outputs.artifact_name }}`
            - **SHA256:** `${{ needs.build.outputs.sha256 }}`
            - **Size:** ${{ needs.build.outputs.size }} bytes
            - **Signed:** ${{ needs.build.outputs.minisign_signature_b64 != '' && 'Yes (Minisign)' || 'No' }}

            ### Manual Installation

            Download the zip file and extract to your Osaurus tools directory.
          files: |
            ./release/${{ needs.build.outputs.artifact_name }}
            ./release/${{ needs.build.outputs.artifact_name }}.minisig
          fail_on_unmatched_files: false
          generate_release_notes: false

  update-registry:
    needs: [build, release]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch }}

      - name: Parse tag
        id: tag
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          TOOL="${TAG%%-*}"
          echo "tool=$TOOL" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Generate registry manifest
        env:
          MANIFEST: ${{ needs.build.outputs.manifest }}
          MINISIGN_PUBLIC_KEY: ${{ secrets.MINISIGN_PUBLIC_KEY }}
          MINISIGN_SIG_B64: ${{ needs.build.outputs.minisign_signature_b64 }}
        run: |
          PLUGIN_ID="${{ needs.build.outputs.plugin_id }}"
          VERSION="${{ needs.build.outputs.version }}"
          ARTIFACT="${{ needs.build.outputs.artifact_name }}"
          SHA256="${{ needs.build.outputs.sha256 }}"
          SIZE="${{ needs.build.outputs.size }}"
          TAG="${{ steps.tag.outputs.tag }}"

          # Decode base64 signature if present
          if [ -n "$MINISIGN_SIG_B64" ]; then
            SIGNATURE=$(echo "$MINISIGN_SIG_B64" | base64 -d)
          else
            SIGNATURE=""
          fi

          # Extract fields from manifest with defaults
          NAME=$(echo "$MANIFEST" | jq -r '.name // empty')
          DESCRIPTION=$(echo "$MANIFEST" | jq -r '.description // ""')
          LICENSE=$(echo "$MANIFEST" | jq -r '.license // "MIT"')
          AUTHORS=$(echo "$MANIFEST" | jq -c '.authors // ["Dinoki Labs"]')
          MIN_MACOS=$(echo "$MANIFEST" | jq -r '.min_macos // "13.0"')
          MIN_OSAURUS=$(echo "$MANIFEST" | jq -r '.min_osaurus // "0.5.0"')
          TOOLS=$(echo "$MANIFEST" | jq -c '[.capabilities.tools // [] | .[] | {name: .id, description: .description}]')

          # Default name from plugin_id suffix if not set
          if [ -z "$NAME" ]; then
            NAME=$(echo "$PLUGIN_ID" | rev | cut -d. -f1 | rev)
            NAME="$(tr '[:lower:]' '[:upper:]' <<< ${NAME:0:1})${NAME:1}"
          fi

          # Download URL for the release artifact
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${TAG}/${ARTIFACT}"

          # Build registry JSON using jq for proper escaping
          jq -n \
            --arg plugin_id "$PLUGIN_ID" \
            --arg name "$NAME" \
            --arg description "$DESCRIPTION" \
            --arg homepage "https://github.com/${{ github.repository }}" \
            --arg license "$LICENSE" \
            --argjson authors "$AUTHORS" \
            --argjson tools "$TOOLS" \
            --arg minisign_pubkey "$MINISIGN_PUBLIC_KEY" \
            --arg min_macos "$MIN_MACOS" \
            --arg min_osaurus "$MIN_OSAURUS" \
            --arg version "$VERSION" \
            --arg release_date "$(date -u +%Y-%m-%d)" \
            --arg url "$DOWNLOAD_URL" \
            --arg sha256 "$SHA256" \
            --argjson size "$SIZE" \
            --arg signature "$SIGNATURE" \
            '{
              plugin_id: $plugin_id,
              name: $name,
              description: $description,
              homepage: $homepage,
              license: $license,
              authors: $authors,
              capabilities: { tools: $tools },
              public_keys: { minisign: $minisign_pubkey },
              requires: { min_macos: $min_macos, osaurus_min_version: $min_osaurus },
              versions: [{
                version: $version,
                release_date: $release_date,
                artifacts: [{
                  os: "macos",
                  arch: "arm64",
                  url: $url,
                  sha256: $sha256,
                  size: $size,
                  min_macos: $min_macos,
                  minisign: { signature: $signature }
                }]
              }]
            }' > /tmp/registry-manifest.json

          echo "Generated registry manifest:"
          cat /tmp/registry-manifest.json | jq .

      - name: Update plugin registry JSON
        run: |
          PLUGIN_ID="${{ needs.build.outputs.plugin_id }}"
          VERSION="${{ needs.build.outputs.version }}"
          REGISTRY_FILE="plugins/${PLUGIN_ID}.json"

          if [ -f "$REGISTRY_FILE" ]; then
            # Merge new version into existing registry file
            # Update tools from manifest and prepend new version to versions array
            jq --slurpfile new /tmp/registry-manifest.json '
              .capabilities.tools = $new[0].capabilities.tools |
              .versions = [$new[0].versions[0]] + .versions |
              .versions |= unique_by(.version)
            ' "$REGISTRY_FILE" > /tmp/updated.json && mv /tmp/updated.json "$REGISTRY_FILE"
          else
            # Use the generated manifest as-is for new plugins
            cp /tmp/registry-manifest.json "$REGISTRY_FILE"
          fi

          echo "Updated $REGISTRY_FILE with version $VERSION"
          cat "$REGISTRY_FILE" | jq .

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GH_PAT }}
          commit-message: "chore: update ${{ needs.build.outputs.plugin_id }} to v${{ needs.build.outputs.version }}"
          title: "Update ${{ needs.build.outputs.plugin_id }} to v${{ needs.build.outputs.version }}"
          body: |
            Automated PR to update the plugin registry after release.

            - **Plugin:** ${{ needs.build.outputs.plugin_id }}
            - **Version:** ${{ needs.build.outputs.version }}
            - **SHA256:** `${{ needs.build.outputs.sha256 }}`
          branch: "release/${{ steps.tag.outputs.tag }}"
          delete-branch: true
