name: Build and Release Plugin

on:
  push:
    tags:
      # Match tags like: time-1.0.0, git-1.0.0
      - "*-*.*.*"
  workflow_dispatch:
    inputs:
      tool:
        description: "Tool to build (time, git, browser, fetch, search, filesystem, all)"
        required: true
        type: choice
        options:
          - time
          - git
          - browser
          - fetch
          - search
          - filesystem
          - all
      version:
        description: "Version (e.g., 1.0.0)"
        required: true
        type: string

permissions:
  contents: write

jobs:
  build:
    runs-on: macos-latest

    outputs:
      plugin_id: ${{ steps.build.outputs.plugin_id }}
      version: ${{ steps.build.outputs.version }}
      artifact_name: ${{ steps.build.outputs.artifact_name }}
      sha256: ${{ steps.build.outputs.sha256 }}
      size: ${{ steps.build.outputs.size }}
      minisign_signature_b64: ${{ steps.sign.outputs.minisign_signature_b64 }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse tag or inputs
        id: parse
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TOOL="${{ github.event.inputs.tool }}"
            VERSION="${{ github.event.inputs.version }}"
          else
            # Parse from tag: tool-version (e.g., time-1.0.0)
            TAG="${GITHUB_REF#refs/tags/}"
            TOOL="${TAG%%-*}"
            VERSION="${TAG#*-}"
          fi
          echo "tool=$TOOL" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building $TOOL version $VERSION"

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Build plugin
        id: build
        run: |
          TOOL="${{ steps.parse.outputs.tool }}"
          VERSION="${{ steps.parse.outputs.version }}"

          ./scripts/build-tool.sh "$TOOL" --version "$VERSION"

          # Read build info
          BUILD_INFO="build/$TOOL/build-info.json"

          PLUGIN_ID=$(python3 -c "import json; print(json.load(open('$BUILD_INFO'))['plugin_id'])")
          ARTIFACT=$(python3 -c "import json; print(json.load(open('$BUILD_INFO'))['artifact'])")
          SHA256=$(python3 -c "import json; print(json.load(open('$BUILD_INFO'))['sha256'])")
          SIZE=$(python3 -c "import json; print(json.load(open('$BUILD_INFO'))['size'])")

          echo "plugin_id=$PLUGIN_ID" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "artifact_name=$ARTIFACT" >> $GITHUB_OUTPUT
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "size=$SIZE" >> $GITHUB_OUTPUT

      - name: Sign with Minisign
        id: sign
        env:
          MINISIGN_SECRET_KEY: ${{ secrets.MINISIGN_SECRET_KEY }}
          MINISIGN_PASSWORD: ${{ secrets.MINISIGN_PASSWORD }}
        run: |
          # Skip if no signing key
          if [ -z "$MINISIGN_SECRET_KEY" ]; then
            echo "No MINISIGN_SECRET_KEY configured, skipping signing"
            echo "minisign_signature_b64=" >> $GITHUB_OUTPUT
            exit 0
          fi

          TOOL="${{ steps.parse.outputs.tool }}"
          ARTIFACT="${{ steps.build.outputs.artifact_name }}"

          # Install minisign
          brew install minisign

          # Write secret key to temp file
          echo "$MINISIGN_SECRET_KEY" > $RUNNER_TEMP/minisign.key

          # Sign the zip using legacy format (-l) for compatibility with Osaurus
          # Modern minisign uses "ED" algorithm ID, but Osaurus expects "Ed" (legacy format)
          cd "build/$TOOL"
          echo "=== Signing $ARTIFACT (legacy format) ==="
          echo "Command: minisign -Slm $ARTIFACT -s <keyfile> -x ${ARTIFACT}.minisig"

          if [ -n "$MINISIGN_PASSWORD" ]; then
            echo "$MINISIGN_PASSWORD" | minisign -Slm "$ARTIFACT" -s $RUNNER_TEMP/minisign.key -x "${ARTIFACT}.minisig"
          else
            minisign -Slm "$ARTIFACT" -s $RUNNER_TEMP/minisign.key -x "${ARTIFACT}.minisig" -W
          fi

          # Debug: Show the signature file contents
          echo "=== Generated signature file ==="
          cat "${ARTIFACT}.minisig"
          echo ""
          echo "=== Signature file format check ==="
          head -1 "${ARTIFACT}.minisig" | grep -q "prehashed" && echo "WARNING: Signature is prehashed!" || echo "OK: Signature is NOT prehashed"

          # Note: Verification would require public key, skipping in CI
          echo "=== Signature generated successfully ==="

          # Read full signature file and base64 encode for safe transport
          SIGNATURE_B64=$(base64 -i "${ARTIFACT}.minisig")
          echo "minisign_signature_b64=$SIGNATURE_B64" >> $GITHUB_OUTPUT

          echo "=== Base64 encoded signature ==="
          echo "$SIGNATURE_B64"

          # Clean up
          rm -f $RUNNER_TEMP/minisign.key

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build.outputs.artifact_name }}
          path: |
            build/${{ steps.parse.outputs.tool }}/${{ steps.build.outputs.artifact_name }}
            build/${{ steps.parse.outputs.tool }}/${{ steps.build.outputs.artifact_name }}.minisig
          if-no-files-found: warn

  release:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.artifact_name }}
          path: ./release

      - name: Parse tag
        id: tag
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TOOL="${{ github.event.inputs.tool }}"
            VERSION="${{ github.event.inputs.version }}"
            TAG="${TOOL}-${VERSION}"
          else
            TAG="${GITHUB_REF#refs/tags/}"
            TOOL="${TAG%%-*}"
            VERSION="${TAG#*-}"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "tool=$TOOL" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: "${{ needs.build.outputs.plugin_id }} v${{ needs.build.outputs.version }}"
          body: |
            ## ${{ needs.build.outputs.plugin_id }} v${{ needs.build.outputs.version }}

            ### Installation

            ```bash
            osaurus tools install ${{ needs.build.outputs.plugin_id }}
            ```

            ### Artifact Details

            - **File:** `${{ needs.build.outputs.artifact_name }}`
            - **SHA256:** `${{ needs.build.outputs.sha256 }}`
            - **Size:** ${{ needs.build.outputs.size }} bytes
            - **Signed:** ${{ needs.build.outputs.minisign_signature_b64 != '' && 'Yes (Minisign)' || 'No' }}

            ### Manual Installation

            Download the zip file and extract to your Osaurus tools directory.
          files: |
            ./release/${{ needs.build.outputs.artifact_name }}
            ./release/${{ needs.build.outputs.artifact_name }}.minisig
          fail_on_unmatched_files: false
          generate_release_notes: false

  update-registry:
    needs: [build, release]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch }}

      - name: Parse tag
        id: tag
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          TOOL="${TAG%%-*}"
          echo "tool=$TOOL" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Update plugin registry JSON
        env:
          MINISIGN_PUBLIC_KEY: ${{ secrets.MINISIGN_PUBLIC_KEY }}
        run: |
          PLUGIN_ID="${{ needs.build.outputs.plugin_id }}"
          VERSION="${{ needs.build.outputs.version }}"
          ARTIFACT="${{ needs.build.outputs.artifact_name }}"
          SHA256="${{ needs.build.outputs.sha256 }}"
          SIZE="${{ needs.build.outputs.size }}"
          TAG="${{ steps.tag.outputs.tag }}"
          MINISIGN_SIG_B64="${{ needs.build.outputs.minisign_signature_b64 }}"

          # Decode base64 signature if present
          if [ -n "$MINISIGN_SIG_B64" ]; then
            MINISIGN_SIG=$(echo "$MINISIGN_SIG_B64" | base64 -d)
          else
            MINISIGN_SIG=""
          fi

          REGISTRY_FILE="plugins/${PLUGIN_ID}.json"

          # Download URL for the release artifact
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${TAG}/${ARTIFACT}"

          # Write signature to temp file for Python to read (preserves newlines)
          echo "$MINISIGN_SIG" > /tmp/minisign_sig.txt

          python3 << EOF
          import json
          import os
          from datetime import datetime

          plugin_id = "$PLUGIN_ID"
          version = "$VERSION"
          sha256 = "$SHA256"
          size = int("$SIZE")
          url = "$DOWNLOAD_URL"
          registry_file = "$REGISTRY_FILE"
          minisign_public_key = os.environ.get("MINISIGN_PUBLIC_KEY", "")

          # Read signature from file to preserve newlines
          try:
              with open('/tmp/minisign_sig.txt', 'r') as f:
                  minisign_sig = f.read().strip()
          except:
              minisign_sig = ""

          # Load existing registry or create new
          try:
              with open(registry_file, 'r') as f:
                  data = json.load(f)
          except FileNotFoundError:
              data = {
                  "plugin_id": plugin_id,
                  "versions": []
              }

          # Add public key if available and not already present
          if minisign_public_key and "public_keys" not in data:
              data["public_keys"] = {"minisign": minisign_public_key}

          # Check if version already exists
          existing_idx = None
          for i, v in enumerate(data.get("versions", [])):
              if v.get("version") == version:
                  existing_idx = i
                  break

          artifact = {
              "os": "macos",
              "arch": "arm64",
              "url": url,
              "sha256": sha256,
              "size": size
          }

          # Add minisign signature if available
          if minisign_sig:
              artifact["minisign"] = {
                  "signature": minisign_sig
              }

          new_version = {
              "version": version,
              "release_date": datetime.utcnow().strftime("%Y-%m-%d"),
              "artifacts": [artifact]
          }

          if existing_idx is not None:
              data["versions"][existing_idx] = new_version
          else:
              data["versions"].insert(0, new_version)

          with open(registry_file, 'w') as f:
              json.dump(data, f, indent=2)

          print(f"Updated {registry_file} with version {version}")
          if minisign_sig:
              print("Minisign signature included")
          EOF

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GH_PAT }}
          commit-message: "chore: update ${{ needs.build.outputs.plugin_id }} to v${{ needs.build.outputs.version }}"
          title: "Update ${{ needs.build.outputs.plugin_id }} to v${{ needs.build.outputs.version }}"
          body: |
            Automated PR to update the plugin registry after release.

            - **Plugin:** ${{ needs.build.outputs.plugin_id }}
            - **Version:** ${{ needs.build.outputs.version }}
            - **SHA256:** `${{ needs.build.outputs.sha256 }}`
          branch: "release/${{ steps.tag.outputs.tag }}"
          delete-branch: true
